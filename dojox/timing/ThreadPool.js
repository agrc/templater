//>>built
define("dojox/timing/ThreadPool",["./_base"],function(){dojo.experimental("dojox.timing.ThreadPool");var e=dojox.timing;return e.threadStates={UNSTARTED:"unstarted",STOPPED:"stopped",PENDING:"pending",RUNNING:"running",SUSPENDED:"suspended",WAITING:"waiting",COMPLETE:"complete",ERROR:"error"},e.threadPriorities={LOWEST:1,BELOWNORMAL:2,NORMAL:3,ABOVENORMAL:4,HIGHEST:5},e.Thread=function(t,i){var a=this;this.state=e.threadStates.UNSTARTED,this.priority=i||e.threadPriorities.NORMAL,this.lastError=null,this.func=t,this.invoke=function(){a.state=e.threadStates.RUNNING;try{t(this),a.state=e.threadStates.COMPLETE}catch(t){a.lastError=t,a.state=e.threadStates.ERROR}}},e.ThreadPool=new function(t,i){var a=this,r=t,n=r,o=i,s=(Math.floor(o/2/r),[]),l=new Array(r+1),d=new dojox.timing.Timer;this.getMaxThreads=function(){return r},this.getAvailableThreads=function(){return n},this.getTickInterval=function(){return o},this.queueUserWorkItem=function(t){var i=t;i instanceof Function&&(i=new e.Thread(i));for(var a=s.length,r=0;r<s.length;r++)if(s[r].priority<i.priority){a=r;break}return a<s.length?s.splice(a,0,i):s.push(i),!0},this.removeQueuedUserWorkItem=function(e){if(e instanceof Function){for(var t=-1,i=0;i<s.length;i++)if(s[i].func==e){t=i;break}return t>-1&&(s.splice(t,1),!0)}for(var t=-1,i=0;i<s.length;i++)if(s[i]==e){t=i;break}return t>-1&&(s.splice(t,1),!0)},this.start=function(){d.start()},this.stop=function(){d.stop()},this.abort=function(){this.stop();for(var e=1;e<l.length;e++)l[e]&&window.clearTimeout(l[e]);for(var t in l[0])this.queueUserWorkItem(t);l[0]={}},this.reset=function(){this.abort(),s=[]},this.sleep=function(e){d.stop(),window.setTimeout(d.start,e)},d.onTick=a.invoke}(16,5e3),dojox.timing.ThreadPool});//# sourceMappingURL=ThreadPool.js.map