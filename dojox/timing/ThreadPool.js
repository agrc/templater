//>>built
define("dojox/timing/ThreadPool",["./_base"],function(){dojo.experimental("dojox.timing.ThreadPool");var e=dojox.timing;return e.threadStates={UNSTARTED:"unstarted",STOPPED:"stopped",PENDING:"pending",RUNNING:"running",SUSPENDED:"suspended",WAITING:"waiting",COMPLETE:"complete",ERROR:"error"},e.threadPriorities={LOWEST:1,BELOWNORMAL:2,NORMAL:3,ABOVENORMAL:4,HIGHEST:5},e.Thread=function(t,i){var o=this;this.state=e.threadStates.UNSTARTED,this.priority=i||e.threadPriorities.NORMAL,this.lastError=null,this.func=t,this.invoke=function(){o.state=e.threadStates.RUNNING;try{t(this),o.state=e.threadStates.COMPLETE}catch(i){o.lastError=i,o.state=e.threadStates.ERROR}}},e.ThreadPool=new function(t,i){var o=this,a=t,r=a,n=i,s=(Math.floor(n/2/a),[]),l=new Array(a+1),d=new dojox.timing.Timer;this.getMaxThreads=function(){return a},this.getAvailableThreads=function(){return r},this.getTickInterval=function(){return n},this.queueUserWorkItem=function(t){var i=t;i instanceof Function&&(i=new e.Thread(i));for(var o=s.length,a=0;a<s.length;a++)if(s[a].priority<i.priority){o=a;break}return o<s.length?s.splice(o,0,i):s.push(i),!0},this.removeQueuedUserWorkItem=function(e){if(e instanceof Function){for(var t=-1,i=0;i<s.length;i++)if(s[i].func==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1}for(var t=-1,i=0;i<s.length;i++)if(s[i]==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1},this.start=function(){d.start()},this.stop=function(){d.stop()},this.abort=function(){this.stop();for(var e=1;e<l.length;e++)l[e]&&window.clearTimeout(l[e]);for(var t in l[0])this.queueUserWorkItem(t);l[0]={}},this.reset=function(){this.abort(),s=[]},this.sleep=function(e){d.stop(),window.setTimeout(d.start,e)},d.onTick=o.invoke}(16,5e3),dojox.timing.ThreadPool});//# sourceMappingURL=ThreadPool.js.map