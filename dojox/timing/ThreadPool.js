//>>built
define("dojox/timing/ThreadPool",["./_base"],function(){dojo.experimental("dojox.timing.ThreadPool");var e=dojox.timing;return e.threadStates={UNSTARTED:"unstarted",STOPPED:"stopped",PENDING:"pending",RUNNING:"running",SUSPENDED:"suspended",WAITING:"waiting",COMPLETE:"complete",ERROR:"error"},e.threadPriorities={LOWEST:1,BELOWNORMAL:2,NORMAL:3,ABOVENORMAL:4,HIGHEST:5},e.Thread=function(t,i){var a=this;this.state=e.threadStates.UNSTARTED,this.priority=i||e.threadPriorities.NORMAL,this.lastError=null,this.func=t,this.invoke=function(){a.state=e.threadStates.RUNNING;try{t(this),a.state=e.threadStates.COMPLETE}catch(i){a.lastError=i,a.state=e.threadStates.ERROR}}},e.ThreadPool=new function(t,i){var a=this,o=t,r=o,n=i,s=(Math.floor(n/2/o),[]),l=new Array(o+1),d=new dojox.timing.Timer;this.getMaxThreads=function(){return o},this.getAvailableThreads=function(){return r},this.getTickInterval=function(){return n},this.queueUserWorkItem=function(t){var i=t;i instanceof Function&&(i=new e.Thread(i));for(var a=s.length,o=0;o<s.length;o++)if(s[o].priority<i.priority){a=o;break}return a<s.length?s.splice(a,0,i):s.push(i),!0},this.removeQueuedUserWorkItem=function(e){if(e instanceof Function){for(var t=-1,i=0;i<s.length;i++)if(s[i].func==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1}for(var t=-1,i=0;i<s.length;i++)if(s[i]==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1},this.start=function(){d.start()},this.stop=function(){d.stop()},this.abort=function(){this.stop();for(var e=1;e<l.length;e++)l[e]&&window.clearTimeout(l[e]);for(var t in l[0])this.queueUserWorkItem(t);l[0]={}},this.reset=function(){this.abort(),s=[]},this.sleep=function(e){d.stop(),window.setTimeout(d.start,e)},d.onTick=a.invoke}(16,5e3),dojox.timing.ThreadPool});//# sourceMappingURL=ThreadPool.js.map