//>>built
define("dojox/timing/ThreadPool",["./_base"],function(){dojo.experimental("dojox.timing.ThreadPool");var e=dojox.timing;return e.threadStates={UNSTARTED:"unstarted",STOPPED:"stopped",PENDING:"pending",RUNNING:"running",SUSPENDED:"suspended",WAITING:"waiting",COMPLETE:"complete",ERROR:"error"},e.threadPriorities={LOWEST:1,BELOWNORMAL:2,NORMAL:3,ABOVENORMAL:4,HIGHEST:5},e.Thread=function(t,i){var a=this;this.state=e.threadStates.UNSTARTED,this.priority=i||e.threadPriorities.NORMAL,this.lastError=null,this.func=t,this.invoke=function(){a.state=e.threadStates.RUNNING;try{t(this),a.state=e.threadStates.COMPLETE}catch(i){a.lastError=i,a.state=e.threadStates.ERROR}}},e.ThreadPool=new function(t,i){var a=this,o=t,n=o,r=i,s=(Math.floor(r/2/o),[]),d=new Array(o+1),l=new dojox.timing.Timer;this.getMaxThreads=function(){return o},this.getAvailableThreads=function(){return n},this.getTickInterval=function(){return r},this.queueUserWorkItem=function(t){var i=t;i instanceof Function&&(i=new e.Thread(i));for(var a=s.length,o=0;o<s.length;o++)if(s[o].priority<i.priority){a=o;break}return a<s.length?s.splice(a,0,i):s.push(i),!0},this.removeQueuedUserWorkItem=function(e){if(e instanceof Function){for(var t=-1,i=0;i<s.length;i++)if(s[i].func==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1}for(var t=-1,i=0;i<s.length;i++)if(s[i]==e){t=i;break}return t>-1?(s.splice(t,1),!0):!1},this.start=function(){l.start()},this.stop=function(){l.stop()},this.abort=function(){this.stop();for(var e=1;e<d.length;e++)d[e]&&window.clearTimeout(d[e]);for(var t in d[0])this.queueUserWorkItem(t);d[0]={}},this.reset=function(){this.abort(),s=[]},this.sleep=function(e){l.stop(),window.setTimeout(l.start,e)},l.onTick=a.invoke}(16,5e3),dojox.timing.ThreadPool});//# sourceMappingURL=ThreadPool.js.map